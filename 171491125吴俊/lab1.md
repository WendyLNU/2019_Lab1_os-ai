﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿# 实验题目：lab1，系统软件启动过程                                                             171491125 吴俊## 1. 实验要求：###a.基于markdown格式来完成，以文本方式为主.  ###b.填写各个基本练习中要求完成的报告内容 完成实验后，请分析ucore_lab中提供的参考答案，并请在实验报告中说明你的实现与参 考答案的区别。   ###c.列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对 二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知 识点） 列出你认为OS原理中很重要，但在实验中没有对应上的知识点。  ##2. 实验内容：  ###练习1：理解通过make生成执行文件的过程。（要求在报告中写 出对下述问题的回答）列出本实验各练习中对应的OS原理的知识点，并说明本实验中的实现部分如何对应和体现了 原理中的基本概念和关键知识点。在此练习中，大家需要通过静态分析代码来了解：  ####1.操作系统镜像文件ucore.img是如何一步一步生成的？(需要比较详细地解释Makefile中每 一条相关命令和命令参数的含义，以及说明命令导致的结果) 。  答：  #####1.make命令执行时，需要一个makefile（或Makefile）文件，以告诉make命令需要怎么样的去 编译和链接程序。因为ucore.img是通过执行命令 make 生成的，所以，要想知道详细步骤，就应该了解Makefile文件的内容。  #####2.当我在ucore_os_lab/labcodes_answer/lab1_result下打开终端运行命令make（根据Makefile文件编译源代码、连接、生成目标文件、可执行文件。）时，跳出了错误make: Nothing to be done for ‘TARGET’。这是因为Makefile的target和目录或文件名字冲突。所以我将bin里的ucore.img 删除后，在执行此命令就不再报错。  #####3.Makefile里的这段代码是指导生成ucore.img的  ![jietu](https://github.com/wujun199826/picture/raw/master/屏幕截图61.png)     这里有图片，是两张，如果显示不出来可能是网络问题，可以去https://github.com/wujun199826/picture查看（稍安勿躁）![ddd](https://github.com/wujun199826/picture/raw/master/SharedScreenshot.jpg)###练习2：使用qemu执行并调试lab1中的软件。（要求在报告中简 要写出练习过程）为了熟悉使用qemu和gdb进行的调试工作，我们进行如下的小练习：  1.从CPU加电后执行的第一条指令开始，单步跟踪BIOS的执行。  只需将gdbinit 内容修改了就可以了。（两张图片）  ![](https://github.com/wujun199826/picture/raw/master/cpu.png)![](https://github.com/wujun199826/picture/raw/master/CPU%20BIOS.png  )#### 2.在初始化位置0x7c00设置实地址断点,测试断点正常。修改gdbinit内容（两张）  ![](https://github.com/wujun199826/picture/raw/master/QQ图片20191019195502.png)  ![](https://github.com/wujun199826/picture/raw/master/break.png)#### 3.从0x7c00开始跟踪代码运行,将单步跟踪反汇编得到的代码与bootasm.S和 bootblock.asm进行比较。 (三张）![](https://github.com/wujun199826/picture/raw/master/QQ图片20191019195446.png)  ![](https://github.com/wujun199826/picture/raw/master/QQ图片20191019195631.png)  ![](https://github.com/wujun199826/picture/raw/master/QQ图片20191019195636.png)是相同的  ####练习3：分析bootloader进入保护模式的过程#####1.为何要开启A20,以及如何开启A20首先关于A20，我们通过查询资料以及说明文档可以知道早期的8086CPU所提供的地址线只有20位，所以可寻址空间为0~(1MB)，但是8086的数据处理位宽16位，无法直接访问1M的地址空间，所以8086提供了段地址加偏移地址的转换机制。PC的寻址结构是segment:offset，segment和offset都是16位寄存器，最大值是0ffffh，所以换算成物理地址的计算方法是把segment左移4位，再加上offset，所以segment:offset所能表示的最大为10ffefh，而这个地址超过了1M，但是超过1M会发生“回卷”的现象不会报错，但是从下一代的80286开始，地址线成为了24位，所能访问的地址空间超过了1M，此时寻址超过1M时会报错，出现了向下不兼容，所以为了解决这个问题采用了A20机制。A20 Gate，将A20地址线控制器 和 键盘控制器的一个输出进行AND操作，这样来控制A20地址线的打开与关闭，所以在实模式下，需要确保A20开关处于关闭状态，这样可以防止访问大于1M的地址空间是在保护模式下，我们需要访问更大的内存空间，所以需要将A20的开关打开，如果在保护模式下，A20的开关未打开的话，此时我们只能访问奇数兆的内存，即只能访问0—1M，2—3M，4—5M……，所以如果我们要进入保护模式，首先就需要把A20开关给打开。  #####2.如何初始化GDT表接下来我们需要了解下GDT表（全局描述符表），在整个操作系统中我们只有一张GDT表，GDT可以放在内存的任意位置，但是CPU必须知道GDT的入口，在Intel里面有一个专门的寄存器GDTR用来存放GDT的入口地址，程序员将GDT设定在内存的某个位置之后，可以通过LGDT指令将GDT的入口地址加载到该寄存器里面，以后CPU就可以通过GDTR来访问GDT了。#####3.如何进入保护模式在这里由于我们需要进入保护模式，所以暂时可以先不用管其他的位，只需关注最低位的PE即可，PE是启用保护位(protection enable)，当设置该位的时候即开启了保护模式，系统上电复位的时候该位默认为0，于是便是实模式；当PE置1的时候，进入保护模式，实质上是开启了段级保护，只是进行了分段，没有开启分页机制，如果要开启分页机制的话我们需要同时置位PE和PG。有了初步了解之后我们便知道的开启保护模式的相关操作，首先开启A20 Gate，其次加载全局描述符表GDT，最后只需要将CR0寄存器的最低位置为1即可。  首先是开启A20，根据上文我们知道需要将第20位为1即可，但是我们需要知道在UCore里是如何将A20置为1的。根据说明书我们可以知道，A20地址线由键盘控制器8042进行控制，我们的A20所对应的是8042里面的P21引脚，所以问题就变成了我们需要将P21引脚置1。  对于8042芯片来说，有两个端口地址60h和64h。对于这两个端口来说，0x64用来发送一个键盘控制命令，0x60用来传递参数，所以将P21引脚置1的操作就变成了，我们首先利用0x64端口传递一个写入的指令，然后由0x60端口读进去相应的参数来将P21置1。由以下的资料我们可以知道，我们首先要先向 64h 发送 0xd1 的指令，写之前需要等待键盘控制器8042空闲，可以通过判断 64h端口中的状态寄存器的值0x2,来判断是否空闲。然后向 60h 发送 0xdf 的指令。   